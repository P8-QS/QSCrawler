This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
CameraMotor.cs
CameraMotor.cs.meta
Collidable.cs
Collidable.cs.meta
Damage.cs
Damage.cs.meta
Enemy.cs
Enemy.cs.meta
EnemyHitbox.cs
EnemyHitbox.cs.meta
Fighter.cs
Fighter.cs.meta
FloatingText.cs
FloatingText.cs.meta
FloatingTextManager.cs
FloatingTextManager.cs.meta
FPSLimiter.cs
FPSLimiter.cs.meta
GameManager.cs
GameManager.cs.meta
JoystickMove.cs
JoystickMove.cs.meta
Managers.meta
Managers/HealthConnectManager.cs
Managers/HealthConnectManager.cs.meta
Mover.cs
Mover.cs.meta
Player.cs
Player.cs.meta
Weapon.cs
Weapon.cs.meta

================================================================
Files
================================================================

================
File: CameraMotor.cs
================
using UnityEngine;

public class CameraMotor : MonoBehaviour
{
    public Transform lookAt;
    public float boundX = 0.15f;
    public float boundY = 0.05f;

    private void LateUpdate()
    {
        Vector3 delta = Vector3.zero;

        // Check if inside the bounds on the X axis
        float deltaX = lookAt.position.x - transform.position.x;
        if (deltaX > boundX || deltaX < -boundX)
        {
            if (transform.position.x < lookAt.position.x)
            {
                delta.x = deltaX - boundX;
            }
            else
            {
                delta.x = deltaX + boundX;
            }
        }

        // Check if inside the bounds on the Y axis
        float deltaY = lookAt.position.y - transform.position.y;
        if (deltaY > boundY || deltaY < -boundY)
        {
            if (transform.position.y < lookAt.position.y)
            {
                delta.y = deltaY - boundY;
            }
            else
            {
                delta.y = deltaY + boundY;
            }
        }

        transform.position += new Vector3(delta.x, delta.y, 0);
    }

}

================
File: CameraMotor.cs.meta
================
fileFormatVersion: 2
guid: f65c0ed3c2d481a449efb92cd11befe6

================
File: Collidable.cs
================
using UnityEngine;

public class Collidable : MonoBehaviour
{
    public ContactFilter2D filter;
    private BoxCollider2D boxCollider;
    private Collider2D[] hits = new Collider2D[10];

    protected virtual void Start()
    {
        boxCollider = GetComponent<BoxCollider2D>();
    }

    protected virtual void Update()
    {
        boxCollider.Overlap(filter, hits);
        for (int i = 0; i < hits.Length; i++)
        {
            if (hits[i] == null)
            {
                continue;
            }
            
            OnCollide(hits[i]);
            
            hits[i] = null;
        }
    }

    protected virtual void OnCollide(Collider2D coll)
    {
        Debug.Log(coll.name);
    }
    
}

================
File: Collidable.cs.meta
================
fileFormatVersion: 2
guid: b1b2fbea8bf1e5149a53c77220ec2da4

================
File: Damage.cs
================
using UnityEngine;

public struct Damage
{

    public Vector3 origin;
    public int damageAmount;
    public float pushForce;

}

================
File: Damage.cs.meta
================
fileFormatVersion: 2
guid: 99ed2d67450b0164894a0ac991220c80

================
File: Enemy.cs
================
using UnityEngine;

public class Enemy : Mover 
{
    // Experience
    public int xpValue = 1;

    // Logic
    public float triggerLength = 1;
    public float chaseLength = 5;
    private bool chasing;
    private bool collidingWithPlayer;
    private Transform playerTransform;
    private Vector3 startingPosition;

    // Hitbox
    public ContactFilter2D filter;
    public BoxCollider2D hitBox;
    public Collider2D[] hits = new Collider2D[10];

    protected override void Start()
    {
        base.Start();
        playerTransform = GameManager.instance.player.transform;
        startingPosition = transform.position;
        hitBox = transform.GetChild(0).GetComponent<BoxCollider2D>();

    }

    protected void FixedUpdate()
    {
        // Is the player in range?
        if (Vector3.Distance(playerTransform.position, startingPosition) < chaseLength)
        {
            if (Vector3.Distance(playerTransform.position, startingPosition) < triggerLength){
                chasing = true;
            }

            if (chasing)
            {
                if (!collidingWithPlayer)
                {
                    UpdateMotor((playerTransform.position - transform.position).normalized);
                }
            }
            else
            {
                UpdateMotor(startingPosition - transform.position);
            }
        }
        else
        {
            UpdateMotor(startingPosition - transform.position);
            chasing = false;
        }

        // Check for overlaps
        collidingWithPlayer = false;
        boxCollider.Overlap(filter, hits);

        for (int i = 0; i < hits.Length; i++)
        {
            if (hits[i] == null)
            {
                continue;
            }

            if (hits[i].tag == "Fighter" && hits[i].name == "Player")
            {
                collidingWithPlayer = true;
            }

            // Reset array
            hits[i] = null;
        }

    }

    protected override void Death()
    {
        Destroy(gameObject);
        GameManager.instance.experience += xpValue;
        GameManager.instance.ShowText("+" + xpValue + " xp", 30, Color.magenta, transform.position, Vector3.up * 1, 1.0f);
    }

}

================
File: Enemy.cs.meta
================
fileFormatVersion: 2
guid: 931989ca136f7784194d1c5d326ebf27

================
File: EnemyHitbox.cs
================
using UnityEngine;

public class EnemyHitbox : Collidable
{
    public int damage = 1;
    public float pushForce = 5.0f;

    protected override void OnCollide(Collider2D coll)
    {
        if (coll.tag == "Fighter" && coll.name == "Player")
        {
            Damage dmg = new Damage
            {
                damageAmount = damage,
                origin = transform.position,
                pushForce = pushForce
            };

            coll.SendMessage("ReceiveDamage", dmg);
        }
    }
}

================
File: EnemyHitbox.cs.meta
================
fileFormatVersion: 2
guid: be47f8e64c180094f85bd603406e3f1b

================
File: Fighter.cs
================
using UnityEngine;

public class Fighter : MonoBehaviour
{
    // Public variables
    public int hitpoint = 10;
    public int maxHitpoint = 10;
    public float pushRecoverySpeed = 0.2f;

    // Immunity
    private float immuneTime = 1.0f;
    private float lastImmune;

    protected Vector3 pushDirection;

    private Collider2D col;

    private void Awake()
    {
        col = GetComponent<Collider2D>();
    }

    protected virtual void ReceiveDamage(Damage dmg)
    {
        if (Time.time - lastImmune > immuneTime)
        {
            lastImmune = Time.time;
            hitpoint -= dmg.damageAmount;
            // Compute direction
            Vector3 direction = transform.position - dmg.origin;
            Debug.Log($"Raw Push Direction: {direction}");

            // Ensure minimum magnitude before normalization
            if (direction.magnitude < 0.1f)
            {
                direction = new Vector3(1, 0, 0); // Default direction if too small
            }
            
            direction.Normalize(); // Now we are sure it has magnitude 1
            pushDirection = direction * Mathf.Max(dmg.pushForce, 2.0f); // Ensure minimum push force

            Debug.Log($"Final Push Direction: {pushDirection}");

            // Determine text color based on whether it's the player or an enemy
            Color damageColor = (gameObject.name == "Player") ? Color.red : Color.yellow;

            // Get random position within collider bounds
            Vector3 textPosition = GetRandomPositionInCollider();

            // Scale font size based on damage
            int fontSize = Mathf.Clamp(30 + dmg.damageAmount * 2, 30, 100);

            // Show damage text
            GameManager.instance.ShowText(dmg.damageAmount.ToString(), fontSize, damageColor, textPosition, Vector3.up, 0.5f);

            if (hitpoint <= 0)
            {
                hitpoint = 0;
                Death();
            }
        }
    }

    private Vector3 GetRandomPositionInCollider()
    {
        if (col is BoxCollider2D box)
        {
            // Get the world size of the box
            Vector3 size = box.bounds.size;
            Vector3 offset = new Vector3(Random.Range(-size.x / 2, size.x / 2), Random.Range(-size.y / 2, size.y / 2), 0);
            return box.bounds.center + offset;
        }
        else if (col is CircleCollider2D circle)
        {
            // Get a random position within the circle
            Vector2 randomInsideCircle = Random.insideUnitCircle * circle.bounds.extents.x; // Uses bounds to be more flexible
            return circle.bounds.center + new Vector3(randomInsideCircle.x, randomInsideCircle.y, 0);
        }

        return transform.position; // Fallback in case there's no recognized collider
    }

    protected virtual void Death()
    {
        // This method is meant to be overwritten 4Head
    }
}

================
File: Fighter.cs.meta
================
fileFormatVersion: 2
guid: 5c0e55f18ec4bef44b6868eb1357bc68

================
File: FloatingText.cs
================
using TMPro;
using UnityEngine;
using UnityEngine.UI;
public class FloatingText
{
    public bool active;
    public TextMeshProUGUI txt;
    public GameObject go;
    public Vector3 motion;
    public float duration;
    public float lastShown;

    public void Show()
    {
        active = true;
        lastShown = Time.time;
        go.SetActive(true);
    }

    public void Hide()
    {
        active = false;
        go.SetActive(false);
    }

    public void UpdateFloatingText()
    {
        if (!active)
            return;

        if (Time.time - lastShown > duration)
        {
            Hide();
            return;
        }

        go.transform.position += motion * Time.deltaTime;
    }

    
}

================
File: FloatingText.cs.meta
================
fileFormatVersion: 2
guid: 2b1128f8ff29cab44a92cb3ddc30e658

================
File: FloatingTextManager.cs
================
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class FloatingTextManager : MonoBehaviour
{
    public GameObject textContainer;
    public GameObject textPrefab;

    private List<FloatingText> floatingTexts = new List<FloatingText>();

    private void Update()
    {
        foreach (FloatingText txt in floatingTexts)
        {
            txt.UpdateFloatingText();
        }
    }

    public void Show(string msg, int fontSize, Color color, Vector3 position, Vector3 motion, float duration)
    {
        FloatingText floatingText = GetFloatingText();

        floatingText.txt.text = msg;
        floatingText.txt.fontSize = fontSize;
        floatingText.txt.color = color;

        floatingText.go.transform.position = position;

        floatingText.motion = motion;
        floatingText.duration = duration;

        floatingText.Show();
    }
        
    private FloatingText GetFloatingText()
    {
        FloatingText txt = floatingTexts.Find(t => !t.active);

        if (txt == null)
        {
            txt = new FloatingText();
            txt.go = Instantiate(textPrefab);
            txt.go.transform.SetParent(textContainer.transform);
            txt.txt = txt.go.GetComponent<TextMeshProUGUI>();
            floatingTexts.Add(txt);
        }

        return txt;
    }

}

================
File: FloatingTextManager.cs.meta
================
fileFormatVersion: 2
guid: 5195185ab022c7e4ca859bdd905163a8

================
File: FPSLimiter.cs
================
using System;
using System.Linq;
using UnityEngine;

public class FPSLimiter : MonoBehaviour
{
    private const double FallbackFPS = 60;

    private void Start()
    {
        var resolutions = Screen.resolutions;
        var maxFPS = resolutions.Max(res => res.refreshRateRatio.value);
        var targetFPS = Math.Max(FallbackFPS, maxFPS);
        
        QualitySettings.vSyncCount = 0;
        Application.targetFrameRate = (int)targetFPS;
        Debug.Log($"RefreshRateRatio: {maxFPS}");
        Debug.Log($"Set targetFrameRate (FPS): {targetFPS}");
    }
}

================
File: FPSLimiter.cs.meta
================
fileFormatVersion: 2
guid: 0258ea94bee7a0340bd5b2712659a0b4

================
File: GameManager.cs
================
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
using Scene = UnityEngine.SceneManagement.Scene;

public class GameManager : MonoBehaviour
{
    public static GameManager instance;
    private void Awake(){
        if (GameManager.instance != null){
            Destroy(gameObject);
            return;
        }

        instance = this;
        SceneManager.sceneLoaded += LoadState;
        DontDestroyOnLoad(gameObject);
    }

    public List<Sprite> playerSprites;
    public List<Sprite> weaponSprites;
    public List<int> xpTable;

    public Player player;
    public FloatingTextManager floatingTextManager;

    public void ShowText(string msg, int fontSize, Color color, Vector3 position, Vector3 motion, float duration){
        floatingTextManager.Show(msg, fontSize, color, position, motion, duration);
    }

    public int experience;

    public void SaveState(){
        Debug.Log("Saving game...");
     
        string s = "";

        s += "0" + "|";
        s += experience.ToString() + "|";
        s += "0";

        PlayerPrefs.SetString("SaveState", s);

    }

    public void LoadState(Scene s, LoadSceneMode mode){
        
        if(!PlayerPrefs.HasKey("SaveState")){
            return;
        }

        string[] data = PlayerPrefs.GetString("SaveState").Split('|');
        experience = int.Parse(data[1]);

        Debug.Log("Loading game...");
    }



}

================
File: GameManager.cs.meta
================
fileFormatVersion: 2
guid: 1a9fa6a339d9f70438c211691f1b28d0

================
File: JoystickMove.cs
================
using UnityEngine;

public class JoystickMove : MonoBehaviour
{
    public Joystick movementJoystick;
    public float playerSpeed;
    private Rigidbody2D rb;
    
    private void Start()
    {
        rb = GetComponent<Rigidbody2D>();
    }

    private void Update()
    {
        rb.linearVelocity = movementJoystick.Direction.y != 0 ? new Vector2(movementJoystick.Direction.x * playerSpeed, movementJoystick.Direction.y * playerSpeed) : Vector2.zero;
    }
}

================
File: JoystickMove.cs.meta
================
fileFormatVersion: 2
guid: a68c896b908dcb449804ff489edba7e9

================
File: Managers.meta
================
fileFormatVersion: 2
guid: f4d113aebfd5c534d964adc42312b76e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Managers/HealthConnectManager.cs
================
using System;
using UnityEngine;
using UnityEngine.Android;

namespace Managers
{
    public class HealthConnectManager : MonoBehaviour
    {
        private AndroidJavaObject _healthConnectClient;
        private AndroidJavaObject _healthConnectPlugin;
        
        private const string ProviderPackageName = "com.google.android.apps.healthdata";
    
        private void Start()
        {
            TestPlugin();
            // CheckHealthConnectAvailability();
        }

        private void TestPlugin()
        {
            if (Application.platform != RuntimePlatform.Android)
            {
                Debug.Log("Not running on Android");
                return;
            }
            
            var unityClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
            var unityActivity = unityClass.GetStatic<AndroidJavaObject>("currentActivity");
            
            unityActivity.Call("runOnUiThread", new AndroidJavaRunnable(() =>
            {
                _healthConnectPlugin = new AndroidJavaObject("org.p8qs.healthconnectplugin.UnityPlugin", unityActivity);
                
                Debug.Log("Checking for health connect permissions");
                var hasPerms = _healthConnectPlugin.Call<int>("HasPermissions");
                
                if (hasPerms == 1)
                {
                    Debug.LogWarning("Has Permissions");
                    _healthConnectPlugin.Call("ReadStepsDay");
                }
                else
                {
                    Debug.LogWarning("Permission denied");
                    _healthConnectPlugin.Call("ReadStepsDay");

                    // RequestHealthConnectPermissions(unityActivity);
                }
            }));
            
            
        }

        private void CheckHealthConnectAvailability()
        {
            if (Application.platform != RuntimePlatform.Android)
            {
                Debug.Log("Not running on Android, skipping Health Connect check.");
                return;
            }
            
            var unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
            var activity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
            var healthConnectClientClass = new AndroidJavaClass("androidx.health.connect.client.HealthConnectClient");
            var availabilityStatus = healthConnectClientClass.CallStatic<int>("getSdkStatus", activity, ProviderPackageName);

            if (availabilityStatus == healthConnectClientClass.GetStatic<int>("SDK_UNAVAILABLE")) 
            {
                Debug.Log("Health Connect SDK is unavailable.");
                return;
            }

            if (availabilityStatus == healthConnectClientClass.GetStatic<int>("SDK_UNAVAILABLE_PROVIDER_UPDATE_REQUIRED"))
            {
                Debug.Log("Health Connect requires an update.");
                RedirectToPlayStore();
            }

            Debug.Log("Health Connect is available.");
            _healthConnectClient = healthConnectClientClass.CallStatic<AndroidJavaObject>("getOrCreate", activity);

            RequestHealthConnectPermissions(activity);
        }

        private void RequestHealthConnectPermissions(AndroidJavaObject activity)
        {
            const string readStepsPermission = "android.permission.health.READ_STEPS";

            if (Permission.HasUserAuthorizedPermission(readStepsPermission))
            {
                Debug.Log("Reading steps permission has been granted.");
                OnStepsPermissionGranted(readStepsPermission);
            }
            else
            {
                Debug.Log("Reading steps permission is not granted. Requesting permission.");
                
                var callbacks = new PermissionCallbacks();
                callbacks.PermissionGranted += OnStepsPermissionGranted;
                Permission.RequestUserPermission(readStepsPermission, callbacks);
            }
        }

        private void OnStepsPermissionGranted(string permissionName)
        {
            Debug.Log($"OnStepsPermissionGranted: {permissionName}");
            _healthConnectPlugin.Call("ReadStepsDay");

            
            // var stepsCount = GetDayStepCount();
            // Debug.Log($"Steps count: {stepsCount}");
        }

        private int GetDayStepCount()
        {
            var ldt = new AndroidJavaClass("java.time.LocalDateTime");
            var now = ldt.CallStatic<AndroidJavaObject>("now");
            var yesterday = now.Call<AndroidJavaObject>("minusDays", (long)1);
            
            var stepsRecordClass = new AndroidJavaClass("androidx.health.connect.client.records.StepsRecord");
            
            var timeRangeFilterClass = new AndroidJavaClass("androidx.health.connect.client.time.TimeRangeFilter");
            var timeRangeFilter = timeRangeFilterClass.CallStatic<AndroidJavaObject>("between", yesterday, now);
            
            var dataOrigin = new AndroidJavaObject("androidx.health.connect.client.records.metadata.DataOrigin", "QSCrawler");
            
            Debug.Log("Created dataOrigin");
            
            var readRequestClass = new AndroidJavaClass("androidx.health.connect.client.request.ReadRecordsRequest");
            Debug.Log("Created request class");
            
            // TODO: FIIIIIIIIIIIIIIIIIIIIIIX
            object[] parameters = {stepsRecordClass, timeRangeFilter, dataOrigin, true, 100, "1"};

            Debug.Log($"stepsrecordclass print: {stepsRecordClass}");
            

            var readRequest = readRequestClass.Call<AndroidJavaObject>(
                "getConstructor",
                stepsRecordClass
                // parameters
            );
            // var readRequest = new AndroidJavaObject("androidx.health.connect.client.request.ReadRecordsRequest", parameters);
            Debug.Log("Created request class");

            
            // Debug.Log($"Read records request: {readRequest}");

            
            return 0;
        }

        private void RedirectToPlayStore()
        {
            throw new System.NotImplementedException();
        }
    }
}

================
File: Managers/HealthConnectManager.cs.meta
================
fileFormatVersion: 2
guid: e66422853b1fb9f45827a044fa6d630d

================
File: Mover.cs
================
using UnityEngine;

public abstract class Mover : Fighter
{
    
    protected Vector3 initialSize;
    protected BoxCollider2D boxCollider;
    protected Vector3 moveDelta;
    protected RaycastHit2D hit;
    protected float ySpeed = 0.75f;
    protected float xSpeed = 1.0f;

    protected virtual void Start()
    {
        boxCollider = GetComponent<BoxCollider2D>();
        initialSize = transform.localScale;
    }

    protected virtual void UpdateMotor(Vector3 input){
        // Reset moveDelta
        moveDelta = input;

        // Swap sprite direction, whether it's going right or left
        if (moveDelta.x > 0)
        {
            transform.localScale = new Vector3(initialSize.x, initialSize.y, initialSize.z);
        }
        else if (moveDelta.x < 0)
        {
            transform.localScale = new Vector3(-initialSize.x, initialSize.y, initialSize.z);
        }

        // Add push vector, reduce it over time
        Debug.Log("Push Direction: " + pushDirection);
        moveDelta += pushDirection;   

        // Reduce push force 
        pushDirection = Vector3.Lerp(pushDirection, Vector3.zero, pushRecoverySpeed);

        // Make sure we can move in this direction by casting a box there first, if the box returns null, we're free to move
        hit = Physics2D.BoxCast(transform.position, boxCollider.size, 0, new Vector2(0, moveDelta.y), Mathf.Abs(moveDelta.y * Time.deltaTime), LayerMask.GetMask("Actor", "Blocking"));
        if (hit.collider == null)
        {
            // Make this move
            transform.Translate(0, moveDelta.y * Time.deltaTime, 0);
        }

        hit = Physics2D.BoxCast(transform.position, boxCollider.size, 0, new Vector2(moveDelta.x, 0), Mathf.Abs(moveDelta.x * Time.deltaTime), LayerMask.GetMask("Actor", "Blocking"));
        if (hit.collider == null)
        {
            // Make this move
            transform.Translate(moveDelta.x * Time.deltaTime, 0, 0);
        }
    }

}

================
File: Mover.cs.meta
================
fileFormatVersion: 2
guid: cb24fc4228015f74fbb930bea2bc9a9c

================
File: Player.cs
================
using UnityEngine;

public class Player : Mover
{
    private JoystickMove joystickMove;
    
    protected override void Start()
    {
        boxCollider = GetComponent<BoxCollider2D>();
        joystickMove = GetComponent<JoystickMove>();
        initialSize = transform.localScale;
    }

    private void FixedUpdate()
    {
        float moveDirection = joystickMove.movementJoystick.Direction.x;
        
        if (moveDirection < 0)
        {
            transform.localScale = new Vector3(-initialSize.x, initialSize.y, initialSize.z);
        }
        else if (moveDirection > 0)
        {
            transform.localScale = new Vector3(initialSize.x, initialSize.y, initialSize.z);
        }

    }
    
}

================
File: Player.cs.meta
================
fileFormatVersion: 2
guid: 2c73ed0c732b1f84b8f44a956b32ac3d

================
File: Weapon.cs
================
using UnityEngine;

public class Weapon : Collidable
{

    public int damagePoint = 1;
    public float pushForce = 2.0f;

    public int weaponLevel = 0;
    public SpriteRenderer spriteRenderer;

    private float ccooldown = 0.5f;
    private float lastSwing;

    protected override void Update()
    {
        base.Update();
        if (Time.time - lastSwing > ccooldown)
        {
            lastSwing = Time.time;
            Swing();
        }
    }

    protected override void OnCollide(Collider2D coll)
    {
        if (coll.tag == "Fighter")
        {
            if (coll.name != "Player")
            {
                Damage dmg = new Damage
                {
                    damageAmount = damagePoint,
                    origin = transform.position,
                    pushForce = pushForce
                };
                coll.SendMessage("ReceiveDamage", dmg);
            }
        }
    }

    private void Swing()
    {
    }

}

================
File: Weapon.cs.meta
================
fileFormatVersion: 2
guid: dd1079b8f4e8365429a2b9ea5e91fc0b



================================================================
End of Codebase
================================================================
